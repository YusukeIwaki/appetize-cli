package cmd

import (
	"fmt"
	"io/ioutil"
	"path/filepath"
	"strings"
	"syscall"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	homedir "github.com/mitchellh/go-homedir"
	"golang.org/x/crypto/ssh/terminal"
)

// configureCmd represents the configure command
var configureCmd = &cobra.Command{
	Use:   "configure",
	Short: "configure appetize-cli. Configuration will be put ~/.appetize.yml",
	Args:  cobra.NoArgs,
	RunE: func(cmd *cobra.Command, args []string) error {
		if terminal.IsTerminal(syscall.Stdin) {
			apiTokenPrompt := PromptReader{
				Instruction:           "Input appetize API token",
				AdditionalInstruction: "API token can be found at https://appetize.io/docs#request-api-token.",
				DefaultValue:          viper.GetString("api_token"),
			}
			apiToken, _ := apiTokenPrompt.Prompt()

			platformPrompt := PromptReader{
				Instruction:           "Input default 'platform' parameter",
				AdditionalInstruction: "If you are an Android developer, it would be strongly recommended to set 'android' here.",
				DefaultValue:          viper.GetString("platform"),
			}
			platform := ""
			for {
				fmt.Println("")
				newPlatform, _ := platformPrompt.Prompt()
				if newPlatform == "" || newPlatform == "android" || newPlatform == "ios" {
					platform = newPlatform
					break
				} else {
					fmt.Println("ERROR: Only 'ios' or 'android' is acceptable", "")
				}
			}

			yaml := AppetizeYaml{
				ApiToken: apiToken,
				Platform: platform,
			}
			if err := yaml.Update(); err != nil {
				return err
			}
		}
		return nil
	},
}

func init() {
	rootCmd.AddCommand(configureCmd)
}

type PromptReader struct {
	Instruction           string
	AdditionalInstruction string
	DefaultValue          string
}

func (reader PromptReader) decoratedInstruction() string {
	if reader.DefaultValue == "" {
		return reader.Instruction
	} else {
		return fmt.Sprintf("%s (current value: '%s')", reader.Instruction, reader.DefaultValue)
	}
}

func (reader PromptReader) readLine() (string, error) {
	instruction := reader.decoratedInstruction()
	if instruction != "" {
		fmt.Println(instruction)
	}
	if reader.AdditionalInstruction != "" {
		fmt.Println(" ", reader.AdditionalInstruction)
		fmt.Println("")
	}
	fmt.Print("> ")
	var line string
	if _, err := fmt.Scanln(&line); err != nil {
		return "", err
	}

	return strings.Trim(line, " \r\n\t"), nil
}

func (reader PromptReader) Prompt() (string, error) {
	newValue, err := reader.readLine()
	if err != nil {
		return reader.DefaultValue, err
	} else if newValue != "" {
		return newValue, nil
	} else {
		return reader.DefaultValue, nil
	}
}

type AppetizeYaml struct {
	ApiToken string
	Platform string
}

func (yaml AppetizeYaml) Update() error {
	lines := []string{
		"# generated by `appetize configure`",
	}

	if yaml.ApiToken != "" {
		lines = append(lines, fmt.Sprintf("api_token: %s", yaml.ApiToken))
	}
	if yaml.Platform != "" {
		lines = append(lines, fmt.Sprintf("platform: %s", yaml.Platform))
	}
	content := []byte(strings.Join(lines, "\n") + "\n")

	// Find home directory.
	home, err := homedir.Dir()
	if err != nil {
		return err
	}
	yamlPath := filepath.Join(home, ".appetize.yml")

	if err := ioutil.WriteFile(yamlPath, content, 0600); err != nil {
		return err
	}

	fmt.Println("")
	fmt.Println("~/.appetize.yml is successfully updated.")
	return nil
}
